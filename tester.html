<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hybrid Encryption</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 50px;
        }
        textarea {
            width: 100%;
            height: 100px;
        }
        button {
            padding: 10px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Hybrid Encryption (AES + RSA)</h1>

    <h3>Text to encrypt</h3>
    <textarea id="plaintext" placeholder="Enter text..."></textarea>
    <button onclick="encryptData()">Encrypt</button>

    <h3>Encrypted Data</h3>
    <textarea id="encryptedData" readonly></textarea>

    <h3>Decrypted Data</h3>
    <textarea id="decryptedData" readonly></textarea>
    <button onclick="decryptData()">Decrypt</button>

    <script>
        let rsaKeyPair;      // Переменная для хранения пары RSA-ключей
        let aesKey;          // Переменная для AES-ключа, который будет использован для шифрования текста
        let encryptedAESKey; // Переменная для хранения зашифрованного AES-ключа
        let encryptedText;   // Переменная для хранения зашифрованного текста
        let iv;              // Вектор инициализации (IV) для алгоритма AES-GCM

        // Функция для генерации пары RSA-ключей
        async function generateRSAKeys() {
            rsaKeyPair = await crypto.subtle.generateKey(
                {
                    name: "RSA-OAEP",                 // Используем алгоритм RSA с OAEP-паддингом
                    modulusLength: 2048,              // Длина ключа 2048 бит
                    publicExponent: new Uint8Array([1, 0, 1]), // Открытая экспонента для RSA
                    hash: "SHA-256",                  // Хэширование с использованием SHA-256
                },
                true,                                 // Делаем ключи экспортируемыми (можно использовать снаружи)
                ["encrypt", "decrypt"]                // Открытый ключ для шифрования, закрытый для расшифровки
            );
        }

        // Функция для шифрования данных (гибридное шифрование: AES для данных, RSA для ключа AES)
        async function encryptData() {
            const plaintext = document.getElementById('plaintext').value; // Получаем текст из поля для ввода

            if (!plaintext) {                      // Если текст пустой, выводим предупреждение
                alert('Please enter some text.');
                return;
            }

            // Генерация AES-ключа для симметричного шифрования
            aesKey = await crypto.subtle.generateKey(
                {
                    name: "AES-GCM",               // Алгоритм AES в режиме GCM (с аутентификацией)
                    length: 256,                   // Длина ключа 256 бит
                },
                true,                              // Делаем ключ экспортируемым
                ["encrypt", "decrypt"]             // Ключ можно использовать для шифрования и расшифровки
            );

            // Генерация случайного вектора инициализации (IV) для AES
            iv = crypto.getRandomValues(new Uint8Array(12));  // 12 байт для IV (рекомендуется для AES-GCM)
            const encodedText = new TextEncoder().encode(plaintext); // Кодируем текст в формат Uint8Array

            // Шифруем текст с использованием AES-GCM
            encryptedText = await crypto.subtle.encrypt(
                {
                    name: "AES-GCM",              // Используем AES-GCM для шифрования
                    iv: iv,                       // Передаем сгенерированный IV
                },
                aesKey,                            // Используем сгенерированный AES-ключ
                encodedText                        // Текст для шифрования (закодирован как Uint8Array)
            );

            // Шифруем AES-ключ с помощью RSA (открытый ключ)
            encryptedAESKey = await crypto.subtle.encrypt(
                {
                    name: "RSA-OAEP",              // Алгоритм RSA-OAEP для шифрования ключа AES
                },
                rsaKeyPair.publicKey,              // Используем открытый ключ RSA для шифрования
                await crypto.subtle.exportKey('raw', aesKey) // Экспортируем AES-ключ в "сыром" формате
            );

            // Отображаем зашифрованный текст и зашифрованный AES-ключ в поле вывода
            document.getElementById('encryptedData').value = btoa(String.fromCharCode(...new Uint8Array(encryptedText))) + '\n\nAES Key (RSA Encrypted): ' + btoa(String.fromCharCode(...new Uint8Array(encryptedAESKey)));
        }

        // Функция для дешифрования данных
        async function decryptData() {
            if (!encryptedText || !encryptedAESKey) { // Проверяем, есть ли данные для расшифровки
                alert('Please encrypt data first.');
                return;
            }

            // Дешифруем AES-ключ с использованием RSA (закрытый ключ)
            const decryptedAESKey = await crypto.subtle.decrypt(
                {
                    name: "RSA-OAEP",              // Алгоритм RSA-OAEP для расшифровки
                },
                rsaKeyPair.privateKey,             // Используем закрытый ключ RSA для расшифровки
                encryptedAESKey                    // Передаем зашифрованный AES-ключ
            );

            // Импортируем дешифрованный AES-ключ
            const aesKeyObj = await crypto.subtle.importKey(
                "raw",                              // Формат ключа — "сырой" (raw)
                decryptedAESKey,                    // Дешифрованный AES-ключ
                {
                    name: "AES-GCM",               // Указываем алгоритм AES-GCM
                },
                true,                              // Делаем ключ снова экспортируемым
                ["decrypt"]                        // Будем использовать ключ для расшифровки
            );

            // Дешифруем текст с использованием AES-GCM
            const decryptedText = await crypto.subtle.decrypt(
                {
                    name: "AES-GCM",              // Алгоритм AES-GCM для расшифровки
                    iv: iv,                       // Передаем тот же IV, что использовался при шифровании
                },
                aesKeyObj,                         // Используем восстановленный AES-ключ
                encryptedText                      // Зашифрованный текст для расшифровки
            );

            // Отображаем расшифрованный текст в поле вывода
            document.getElementById('decryptedData').value = new TextDecoder().decode(decryptedText); // Декодируем Uint8Array обратно в строку
        }

        // Генерация RSA-ключей при загрузке страницы
        window.onload = generateRSAKeys;  // При загрузке страницы сразу генерируем RSA-ключи
    </script>
</body>
</html>
